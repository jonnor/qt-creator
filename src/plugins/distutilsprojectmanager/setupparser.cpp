/**************************************************************************
**
** This file is part of Qt Creator
**
** Copyright (c) 2010-2011 Openismus GmbH.
**   Authors: Peter Penz (ppenz@openismus.com)
**            Patricia Santana Cruz (patriciasantanacruz@gmail.com)
**
** Contact: Nokia Corporation (info@qt.nokia.com)
**
**
** GNU Lesser General Public License Usage
**
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this file.
** Please review the following information to ensure the GNU Lesser General
** Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** Other Usage
**
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
** If you have questions regarding the use of this file, please contact
** Nokia at info@qt.nokia.com.
**
**************************************************************************/

#include "setupparser.h"

#include <utils/qtcassert.h>
#include "json.h"

#include <QFile>
#include <QFileInfoList>
#include <QMutexLocker>
#include <QProcess>

using namespace Utils;
using namespace DistutilsProjectManager::Internal;

SetupParser::SetupParser(const QString &projectFilePath) :
    QObject(),
    m_success(false),
    m_cancel(false),
    m_mutex(),
    m_projectDirectory(QFileInfo(projectFilePath).dir()),
    m_setupFilePath(QFileInfo(projectFilePath).absoluteFilePath()),
    m_scripts(),
    m_packages()
{
}

bool SetupParser::parse()
{
    qDebug() << __PRETTY_FUNCTION__;

    m_mutex.lock();
    m_cancel = false;
    m_mutex.unlock(),

    m_success = true;
    m_scripts.clear();
    m_sourceFiles.clear();
    m_packages.clear();

    /* The rules for which source files are considered to be part of the distribution
     * can be found at http://docs.python.org/distutils/sourcedist.html#manifest
     *
     * Note that if a manifest exists, and is not generated by distutils from a
     * manifest template, the manifest should be read directly and below rules should _not_ apply.
     * This is currently ignored. */

    /* Project file is always added */
    m_sourceFiles.append(m_setupFilePath);

    /* Added if existing. */
    addSourceFileIfExisting("setup.cfg");
    addSourceFileIfExisting("README.txt");
    addSourceFileIfExisting("README");

    /* Add files specified by the project file
     * Call helper program to actually parse the setup file */

    /* FIXME: can't assume that the program exists in PATH like this */
    QString program = "distutils_extract.py";
    QStringList arguments;
    arguments << m_setupFilePath;
    QProcess extractionHelper;
    extractionHelper.start(program, arguments);

    bool helper_success = extractionHelper.waitForFinished(10000);

    if (extractionHelper.exitCode() != 0 || !helper_success) {
        m_success = false;
        qWarning() << extractionHelper.error();
        qWarning() << extractionHelper.readAllStandardOutput();
        qWarning() << extractionHelper.readAllStandardError();
    } else {
        m_success = parseHelperOutput(extractionHelper.readAllStandardOutput());
    }

    bool haveManifestTemplate = addSourceFileIfExisting("MANIFEST.in");
    if (haveManifestTemplate) {
        parseManifestTemplate("MANIFEST.in");
    }

    return m_success;
}

bool SetupParser::parseManifestTemplate(const QString &manifestTemplatePath)
{
    Q_UNUSED(manifestTemplatePath);
    /* TODO: Files specified by manifest template */
    return false;
}

bool SetupParser::parseHelperOutput(QByteArray output) {

    qDebug() << __PRETTY_FUNCTION__ << output;

    JsonValue *document = JsonValue::create(QString::fromUtf8(output));

    JsonObjectValue *rootObject = document->toObject();
    JsonObjectValue *setupObject = rootObject->member("setup")->toObject();
    JsonObjectValue *setupKwArgsObject = setupObject->member("kwargs")->toObject();

    /* Python source files */
    if (setupKwArgsObject->hasMember("packages")) {
        JsonArrayValue *packages = setupKwArgsObject->member("packages")->toArray();
        qDebug() << packages;

        foreach (JsonValue *package, packages->elements()) {
            QString packageName = package->toString()->value();
            // If the package name contains . it is a subpackage and exists in a subdirectory
            QString packagePath = packageName.replace(".", "/");
            QDir packageDir(m_projectDirectory.filePath(packagePath));

            QStringList pythonFileFilter;
            pythonFileFilter << "*.py";
            packageDir.setNameFilters(pythonFileFilter);

            foreach (const QString &pyFile, packageDir.entryList()) {
                addSourceFileIfExisting(packagePath + QString("/") + pyFile);
            }
        }
    }

    /* C/C++ source files */
    if (setupKwArgsObject->hasMember("ext_packages")) {
        /* TODO */
    }

    /* Scripts */
    if (setupKwArgsObject->hasMember("scripts")) {
        JsonArrayValue *scripts = setupKwArgsObject->member("scripts")->toArray();
        foreach (JsonValue *script, scripts->elements()) {
            addSourceFileIfExisting(script->toString()->value());
        }
    }

    /* Package data */
    if (setupKwArgsObject->hasMember("package_data")) {
        /* TODO */
    }

    /* Additional data */
    if (setupKwArgsObject->hasMember("data_files")) {
        /* TODO */
    }

    return true;
}

bool SetupParser::addSourceFileIfExisting(const QString& fileName)
{
    QFileInfo fileInfo(m_projectDirectory, fileName);
    if (fileInfo.exists()) {
        m_sourceFiles.append(fileName);
        return true;
    }
    return false;
}

void SetupParser::cancel()
{
    QMutexLocker locker(&m_mutex);
    m_cancel = true;
}

bool SetupParser::isCanceled() const
{
    QMutexLocker locker(&m_mutex);
    return m_cancel;
}

QMap<QString, QStringList> SetupParser::packages() const
{
    return m_packages;
}

QStringList SetupParser::scripts() const
{
    return m_scripts;
}

QStringList SetupParser::projectFiles() const
{
    return m_projectFiles;
}

QStringList SetupParser::sourceFiles() const
{
    return m_sourceFiles;
}
